"use strict";
function prefix() {
    var rules;
    var compoundRuleCodes;
    var dictionaryTable;
    var compoundRules = [];
    var replacementTable = [];
    var flags = Object.create(null);
    /**
     * Removes comment lines and then cleans up blank lines and trailing whitespace.
     *
     * @param {String} data The data from an affix file.
     * @return {String} The cleaned-up data.
     */
    function removeAffixComments(data) {
        // Remove comments
        data = data.replace(/#.*$/mg, '');
        // Trim each line
        data = data.replace(/^\s\s*/m, '').replace(/\s\s*$/m, '');
        // Remove blank lines.
        data = data.replace(/\n{2,}/g, '\n');
        // Trim the entire string
        data = data.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        return data;
    }
    function parseRuleCodes(textCodes) {
        if (!textCodes) {
            return [];
        }
        else if (!('FLAG' in flags)) {
            return textCodes.split('');
        }
        else if (flags.FLAG === 'long') {
            var flags_1 = [];
            for (var i = 0, _len = textCodes.length; i < _len; i += 2) {
                flags_1.push(textCodes.substr(i, 2));
            }
            return flags_1;
        }
        else if (flags.FLAG === 'num') {
            return textCodes.split(',');
        }
    }
    /**
     * Applies an affix rule to a word.
     *
     * @param {String} word The base word.
     * @param {Object} rule The affix rule.
     * @returns {String[]} The new words generated by the rule.
     */
    function applyRule(word, rule) {
        var entries = rule.entries;
        var newWords = [];
        for (var i = 0, _len = entries.length; i < _len; i++) {
            var entry_1 = entries[i];
            if (!entry_1.match || word.match(entry_1.match)) {
                var newWord = word;
                if (entry_1.remove) {
                    newWord = newWord.replace(entry_1.remove, '');
                }
                if (rule.type === 'SFX') {
                    newWord = newWord + entry_1.add;
                }
                else {
                    newWord = entry_1.add + newWord;
                }
                newWords.push(newWord);
                if (entry_1.continuationClasses) {
                    for (var j = 0, _jlen = entry_1.continuationClasses.length; j < _jlen; j++) {
                        var continuationRule = rules[entry_1.continuationClasses[j]];
                        if (continuationRule) {
                            newWords = newWords.concat(applyRule(newWord, continuationRule));
                        }
                    }
                }
            }
        }
        return newWords;
    }
    ;
    /**
     * Parse the rules out from a .aff file.
     *
     * @param {String} data The contents of the affix file.
     * @returns object The rules from the file.
     */
    function parseAAF(data) {
        var rules = Object.create(null);
        var line, subline, numEntries, lineParts;
        var i, j, _len, _jlen;
        // Remove comment lines
        data = removeAffixComments(data);
        var lines = data.split('\n');
        for (i = 0, _len = lines.length; i < _len; i++) {
            line = lines[i];
            var definitionParts = line.split(/\s+/);
            var ruleType = definitionParts[0];
            if (ruleType == 'PFX' || ruleType == 'SFX') {
                var ruleCode = definitionParts[1];
                var combineable = definitionParts[2];
                numEntries = parseInt(definitionParts[3], 10);
                var entries = [];
                for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                    subline = lines[j];
                    lineParts = subline.split(/\s+/);
                    var charactersToRemove = lineParts[2];
                    var additionParts = lineParts[3].split('/');
                    var charactersToAdd = additionParts[0];
                    if (charactersToAdd === '0') {
                        charactersToAdd = '';
                    }
                    var continuationClasses = parseRuleCodes(additionParts[1]);
                    var regexToMatch = lineParts[4];
                    var entry_2 = { add: charactersToAdd };
                    if (continuationClasses.length > 0) {
                        entry_2.continuationClasses = continuationClasses;
                    }
                    if (regexToMatch !== '.') {
                        if (ruleType === 'SFX') {
                            entry_2.match = new RegExp(regexToMatch + '$');
                        }
                        else {
                            entry_2.match = new RegExp('^' + regexToMatch);
                        }
                    }
                    if (charactersToRemove != '0') {
                        if (ruleType === 'SFX') {
                            entry_2.remove = new RegExp(charactersToRemove + '$');
                        }
                        else {
                            entry_2.remove = charactersToRemove;
                        }
                    }
                    entries.push(entry_2);
                }
                rules[ruleCode] = {
                    combineable: combineable === 'Y',
                    entries: entries,
                    type: ruleType,
                };
                i += numEntries;
            }
            else if (ruleType === 'COMPOUNDRULE') {
                numEntries = parseInt(definitionParts[1], 10);
                for (j = i + 1, _jlen = i + 1 + numEntries; j < _jlen; j++) {
                    line = lines[j];
                    lineParts = line.split(/\s+/);
                    compoundRules.push(lineParts[1]);
                }
                i += numEntries;
            }
            else if (ruleType === 'REP') {
                lineParts = line.split(/\s+/);
                if (lineParts.length === 3) {
                    replacementTable.push([lineParts[1], lineParts[2]]);
                }
            }
            else {
                // ONLYINCOMPOUND
                // COMPOUNDMIN
                // FLAG
                // KEEPCASE
                // NEEDAFFIX
                flags[ruleType] = definitionParts[1];
            }
        }
        return rules;
    }
    /**
     * Removes comment lines and then cleans up blank lines and trailing whitespace.
     *
     * @param {String} data The data from a .dic file.
     * @return {String} The cleaned-up data.
     */
    function removeDicComments(data) {
        // I can't find any official documentation on it, but at least the de_DE
        // dictionary uses tab-indented lines as comments.
        // Remove comments
        data = data.replace(/^\t.*$/mg, '');
        return data;
    }
    function parseDIC(data) {
        data = removeDicComments(data);
        var lines = data.split('\n');
        var dictionaryTable = Object.create(null);
        var addWord = function (word, rules) {
            // Some dictionaries will list the same word multiple times with different rule sets.
            if (!dictionaryTable[word]) {
                dictionaryTable[word] = null;
            }
            if (rules.length > 0) {
                if (dictionaryTable[word] === null) {
                    dictionaryTable[word] = [];
                }
                dictionaryTable[word].push(rules);
            }
        };
        // The first line is the number of words in the dictionary.
        for (var i = 1, _len = lines.length; i < _len; i++) {
            var line = lines[i];
            var parts = line.split('/', 2);
            var word = parts[0];
            // Now for each affix rule, generate that form of the word.
            if (parts.length > 1) {
                var ruleCodesArray = parseRuleCodes(parts[1]);
                // Save the ruleCodes for compound word situations.
                if (!('NEEDAFFIX' in flags) || ruleCodesArray.indexOf(flags.NEEDAFFIX) == -1) {
                    addWord(word, ruleCodesArray);
                }
                for (var j = 0, _jlen = ruleCodesArray.length; j < _jlen; j++) {
                    var code = ruleCodesArray[j];
                    var rule = rules[code];
                    if (rule) {
                        var newWords = applyRule(word, rule);
                        for (var ii = 0, _iilen = newWords.length; ii < _iilen; ii++) {
                            var newWord = newWords[ii];
                            addWord(newWord, []);
                            if (rule.combineable) {
                                for (var k = j + 1; k < _jlen; k++) {
                                    var combineCode = ruleCodesArray[k];
                                    var combineRule = rules[combineCode];
                                    if (combineRule) {
                                        if (combineRule.combineable && (rule.type != combineRule.type)) {
                                            var otherNewWords = applyRule(newWord, combineRule);
                                            for (var iii = 0, _iiilen = otherNewWords.length; iii < _iiilen; iii++) {
                                                var otherNewWord = otherNewWords[iii];
                                                addWord(otherNewWord, []);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (compoundRuleCodes[code]) {
                        compoundRuleCodes[code].push(word);
                    }
                }
            }
            else {
                addWord(word.trim(), []);
            }
        }
        return dictionaryTable;
    }
    /**
     * Checks whether a word exists in the current dictionary.
     *
     * @param {String} word The word to check.
     * @returns {Boolean}
     */
    function checkExact(word) {
        var ruleCodes = dictionaryTable[word];
        var i, _len;
        if (typeof ruleCodes === 'undefined') {
            // Check if this might be a compound word.
            if ('COMPOUNDMIN' in flags && word.length >= Number(flags.COMPOUNDMIN)) {
                for (i = 0, _len = compoundRules.length; i < _len; i++) {
                    if (word.match(compoundRules[i])) {
                        return true;
                    }
                }
            }
        }
        else if (ruleCodes === null) {
            // a null (but not undefined) value for an entry in the dictionary table
            // means that the word is in the dictionary but has no flags.
            return true;
        }
        else if (typeof ruleCodes === 'object') {
            for (i = 0, _len = ruleCodes.length; i < _len; i++) {
                if (!hasFlag(word, 'ONLYINCOMPOUND', ruleCodes[i])) {
                    return true;
                }
            }
        }
        return false;
    }
    /**
     * Looks up whether a given word is flagged with a given flag.
     *
     * @param {String} word The word in question.
     * @param {String} flag The flag in question.
     * @return {Boolean}
     */
    function hasFlag(word, flag, wordFlags) {
        if (flag in flags) {
            if (typeof wordFlags === 'undefined') {
                wordFlags = Array.prototype.concat.apply([], dictionaryTable[word]);
            }
            if (wordFlags && wordFlags.indexOf(flags[flag]) !== -1) {
                return true;
            }
        }
        return false;
    }
    var alphabet = '';
    var memoized = Object.create(null);
    var proc = {
        setup: function (affData, wordsData) {
            rules = parseAAF(affData);
            // Save the rule codes that are used in compound rules.
            compoundRuleCodes = Object.create(null);
            for (var i = 0, _len = compoundRules.length; i < _len; i++) {
                var rule = compoundRules[i];
                for (var j = 0, _jlen = rule.length; j < _jlen; j++) {
                    compoundRuleCodes[rule[j]] = [];
                }
            }
            // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC
            // will do the work of saving the list of words that are compound-only.
            if (flags.ONLYINCOMPOUND) {
                compoundRuleCodes[flags.ONLYINCOMPOUND] = [];
            }
            dictionaryTable = parseDIC(wordsData);
            // Get rid of any codes from the compound rule codes that are never used
            // (or that were special regex characters).  Not especially necessary...
            for (var i in compoundRuleCodes) {
                if (compoundRuleCodes[i].length === 0) {
                    delete compoundRuleCodes[i];
                }
            }
            // Build the full regular expressions for each compound rule.
            // I have a feeling (but no confirmation yet) that this method of
            // testing for compound words is probably slow.
            for (var i = 0, _len = compoundRules.length; i < _len; i++) {
                var ruleText = compoundRules[i];
                var expressionText = '';
                for (var j = 0, _jlen = ruleText.length; j < _jlen; j++) {
                    var character = ruleText[j];
                    if (character in compoundRuleCodes) {
                        expressionText += '(' + compoundRuleCodes[character].join('|') + ')';
                    }
                    else {
                        expressionText += character;
                    }
                }
                compoundRules[i] = new RegExp(expressionText, 'i');
            }
        },
        /**
         * Checks whether a word or a capitalization variant exists in the current dictionary.
         * The word is trimmed and several variations of capitalizations are checked.
         * If you want to check a word without any changes made to it, call checkExact()
         *
         * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
         *
         * @param {String} aWord The word to check.
         * @returns {Boolean}
         */
        check: function (aWord) {
            // Remove leading and trailing whitespace
            var trimmedWord = aWord.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            if (checkExact(trimmedWord)) {
                return true;
            }
            // The exact word is not in the dictionary.
            if (trimmedWord.toUpperCase() === trimmedWord) {
                // The word was supplied in all uppercase.
                // Check for a capitalized form of the word.
                var capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();
                if (hasFlag(capitalizedWord, 'KEEPCASE')) {
                    // Capitalization variants are not allowed for this word.
                    return false;
                }
                if (checkExact(capitalizedWord)) {
                    return true;
                }
            }
            var lowercaseWord = trimmedWord.toLowerCase();
            if (lowercaseWord !== trimmedWord) {
                if (hasFlag(lowercaseWord, 'KEEPCASE')) {
                    // Capitalization variants are not allowed for this word.
                    return false;
                }
                // Check for a lowercase form
                if (checkExact(lowercaseWord)) {
                    return true;
                }
            }
            return false;
        },
        /**
         * Returns a list of suggestions for a misspelled word.
         *
         * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
         * This suggestor is primitive, but it works.
         *
         * @param {String} word The misspelling.
         * @param {Number} limit The maximum number of suggestions to return.
         * @returns {String[]} The array of suggestions.
         */
        suggest: function (word, limit) {
            if (memoized.hasOwnProperty(word)) {
                var memoizedLimit = memoized[word]['limit'];
                // Only return the cached list if it's big enough or if there weren't enough suggestions
                // to fill a smaller limit.
                if (limit <= memoizedLimit || memoized[word]['suggestions'].length < memoizedLimit) {
                    return memoized[word]['suggestions'].slice(0, limit);
                }
            }
            if (proc.check(word))
                return [];
            // Check the replacement table.
            for (var i = 0, _len = replacementTable.length; i < _len; i++) {
                var replacementEntry = replacementTable[i];
                if (word.indexOf(replacementEntry[0]) !== -1) {
                    var correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);
                    if (proc.check(correctedWord)) {
                        return [correctedWord];
                    }
                }
            }
            /*
            if (!self.alphabet) {
              // Use the alphabet as implicitly defined by the words in the dictionary.
              var alphaHash = {};
      
              for (var i in self.dictionaryTable) {
                for (var j = 0, _len = i.length; j < _len; j++) {
                  alphaHash[i[j]] = true;
                }
              }
      
              for (var i in alphaHash) {
                self.alphabet += i;
              }
      
              var alphaArray = self.alphabet.split('');
              alphaArray.sort();
              self.alphabet = alphaArray.join('');
            }
            */
            function edits1(words) {
                var rv = [];
                var ii, i, j, _iilen, _len, _jlen;
                for (ii = 0, _iilen = words.length; ii < _iilen; ii++) {
                    var word_1 = words[ii];
                    for (i = 0, _len = word_1.length + 1; i < _len; i++) {
                        var s = [word_1.substring(0, i), word_1.substring(i)];
                        if (s[1]) {
                            rv.push(s[0] + s[1].substring(1));
                        }
                        // Eliminate transpositions of identical letters
                        if (s[1].length > 1 && s[1][1] !== s[1][0]) {
                            rv.push(s[0] + s[1][1] + s[1][0] + s[1].substring(2));
                        }
                        if (s[1]) {
                            for (j = 0, _jlen = alphabet.length; j < _jlen; j++) {
                                // Eliminate replacement of a letter by itself
                                if (alphabet[j] != s[1].substring(0, 1)) {
                                    rv.push(s[0] + alphabet[j] + s[1].substring(1));
                                }
                            }
                        }
                        if (s[1]) {
                            for (j = 0, _jlen = alphabet.length; j < _jlen; j++) {
                                rv.push(s[0] + alphabet[j] + s[1]);
                            }
                        }
                    }
                }
                return rv;
            }
            function known(words) {
                var rv = [];
                for (var i = 0, _len = words.length; i < _len; i++) {
                    if (proc.check(words[i])) {
                        rv.push(words[i]);
                    }
                }
                return rv;
            }
            function correct(word) {
                // Get the edit-distance-1 and edit-distance-2 forms of this word.
                var ed1 = edits1([word]);
                var ed2 = edits1(ed1);
                var corrections = known(ed1.concat(ed2));
                // Sort the edits based on how many different ways they were created.
                var weightedCorrections = {};
                for (var i = 0, _len = corrections.length; i < _len; i++) {
                    if (!(corrections[i] in weightedCorrections)) {
                        weightedCorrections[corrections[i]] = 1;
                    }
                    else {
                        weightedCorrections[corrections[i]] += 1;
                    }
                }
                var sortedCorrections = [];
                for (var i in weightedCorrections) {
                    if (weightedCorrections.hasOwnProperty(i)) {
                        sortedCorrections.push([i, weightedCorrections[i]]);
                    }
                }
                function sorter(a, b) {
                    if (a[1] < b[1]) {
                        return -1;
                    }
                    return 1;
                }
                sortedCorrections.sort(sorter).reverse();
                var rv = [];
                var capitalizationScheme = 'lowercase';
                if (word.toUpperCase() === word) {
                    capitalizationScheme = 'uppercase';
                }
                else if (word.substr(0, 1).toUpperCase() + word.substr(1).toLowerCase() === word) {
                    capitalizationScheme = 'capitalized';
                }
                for (var i = 0, _len = Math.min(limit, sortedCorrections.length); i < _len; i++) {
                    if ('uppercase' === capitalizationScheme) {
                        sortedCorrections[i][0] = sortedCorrections[i][0].toUpperCase();
                    }
                    else if ('capitalized' === capitalizationScheme) {
                        sortedCorrections[i][0] = sortedCorrections[i][0].substr(0, 1).toUpperCase() + sortedCorrections[i][0].substr(1);
                    }
                    if (!hasFlag(sortedCorrections[i][0], 'NOSUGGEST')) {
                        rv.push(sortedCorrections[i][0]);
                    }
                }
                return rv;
            }
            memoized[word] = {
                'suggestions': correct(word),
                'limit': limit
            };
            return memoized[word]['suggestions'];
        }
    };
    return proc;
}
function entry(data) {
    var proc = prefix();
    var result;
    switch (data.action) {
        case 'setup':
            proc.setup(data.affData, data.wordsData);
            break;
        case 'check':
            result = proc.check(data.word);
            break;
        case 'suggest':
            result = proc.suggest(data.word, data.limit);
            break;
        default:
            throw new Error("Unknown action from data: " + JSON.stringify(data));
    }
    postMessage(result, '');
}
exports.prefixStr = "var proc = (" + prefix + ")();";
exports.entryStr = "(" + String(entry).replace('const proc = prefix()', '') + ")(data);";
